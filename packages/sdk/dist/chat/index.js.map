{"version":3,"sources":["../../src/utils/errors.ts","../../src/providers/base.ts","../../src/chat/index.ts"],"names":["chat"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Error Handling and Retry Mechanisms\n * \n * Implements exponential backoff, circuit breaker patterns, and provider-specific error handling\n */\n\nimport type { \n  SDKError, \n  RateLimitError, \n  AuthenticationError, \n  ValidationError, \n  ApiProvider,\n  RequestMetrics \n} from '../types';\n\n/**\n * Custom SDK Error Classes\n */\nexport class BaseSDKError extends Error implements SDKError {\n  public readonly code: string;\n  public readonly statusCode?: number;\n  public readonly provider?: ApiProvider;\n  public readonly requestId?: string;\n  public readonly details?: Record<string, any>;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      statusCode?: number;\n      provider?: ApiProvider;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = this.constructor.name;\n    this.code = code;\n    this.statusCode = options?.statusCode;\n    this.provider = options?.provider;\n    this.requestId = options?.requestId;\n    this.details = options?.details;\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SDKRateLimitError extends BaseSDKError implements RateLimitError {\n  public readonly code = 'RATE_LIMIT_EXCEEDED';\n  public readonly retryAfter?: number;\n  public readonly limitType: 'requests' | 'tokens' | 'cost';\n\n  constructor(\n    message: string,\n    limitType: 'requests' | 'tokens' | 'cost',\n    options?: {\n      retryAfter?: number;\n      statusCode?: number;\n      provider?: ApiProvider;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, 'RATE_LIMIT_EXCEEDED', options);\n    this.limitType = limitType;\n    this.retryAfter = options?.retryAfter;\n  }\n}\n\nexport class SDKAuthenticationError extends BaseSDKError implements AuthenticationError {\n  public readonly code = 'AUTHENTICATION_FAILED';\n  public readonly provider: ApiProvider;\n\n  constructor(\n    message: string,\n    provider: ApiProvider,\n    options?: {\n      statusCode?: number;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, 'AUTHENTICATION_FAILED', { ...options, provider });\n    this.provider = provider;\n  }\n}\n\nexport class SDKValidationError extends BaseSDKError implements ValidationError {\n  public readonly code = 'VALIDATION_ERROR';\n  public readonly field: string;\n  public readonly value: any;\n\n  constructor(\n    message: string,\n    field: string,\n    value: any,\n    options?: {\n      statusCode?: number;\n      provider?: ApiProvider;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, 'VALIDATION_ERROR', options);\n    this.field = field;\n    this.value = value;\n  }\n}\n\n/**\n * Error Factory - Creates appropriate error types from provider responses\n */\nexport class ErrorFactory {\n  static fromProviderError(\n    error: any,\n    provider: ApiProvider,\n    requestId?: string\n  ): SDKError {\n    // OpenAI error handling\n    if (provider === 'openai') {\n      return this.fromOpenAIError(error, requestId);\n    }\n\n    // Claude error handling\n    if (provider === 'claude') {\n      return this.fromClaudeError(error, requestId);\n    }\n\n    // Generic error handling\n    return this.fromGenericError(error, provider, requestId);\n  }\n\n  private static fromOpenAIError(error: any, requestId?: string): SDKError {\n    const statusCode = error.status || error.statusCode || 500;\n    const message = error.message || error.error?.message || 'OpenAI API error';\n\n    // Rate limiting\n    if (statusCode === 429) {\n      const retryAfter = error.headers?.['retry-after'] \n        ? parseInt(error.headers['retry-after'], 10) \n        : undefined;\n      \n      return new SDKRateLimitError(\n        message,\n        'requests',\n        {\n          retryAfter,\n          statusCode,\n          provider: 'openai',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Authentication errors\n    if (statusCode === 401) {\n      return new SDKAuthenticationError(\n        message,\n        'openai',\n        {\n          statusCode,\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Validation errors\n    if (statusCode === 400) {\n      return new SDKValidationError(\n        message,\n        error.error?.param || 'unknown',\n        error.error?.code || 'unknown',\n        {\n          statusCode,\n          provider: 'openai',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Generic OpenAI error\n    return new BaseSDKError(\n      message,\n      'OPENAI_API_ERROR',\n      {\n        statusCode,\n        provider: 'openai',\n        requestId,\n        details: { originalError: error },\n        cause: error\n      }\n    );\n  }\n\n  private static fromClaudeError(error: any, requestId?: string): SDKError {\n    const statusCode = error.status || error.statusCode || 500;\n    const message = error.message || error.error?.message || 'Claude API error';\n\n    // Rate limiting\n    if (statusCode === 429) {\n      const retryAfter = error.headers?.['retry-after'] \n        ? parseInt(error.headers['retry-after'], 10) \n        : undefined;\n      \n      return new SDKRateLimitError(\n        message,\n        'requests',\n        {\n          retryAfter,\n          statusCode,\n          provider: 'claude',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Authentication errors\n    if (statusCode === 401) {\n      return new SDKAuthenticationError(\n        message,\n        'claude',\n        {\n          statusCode,\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Validation errors\n    if (statusCode === 400) {\n      return new SDKValidationError(\n        message,\n        error.error?.param || 'unknown',\n        error.error?.code || 'unknown',\n        {\n          statusCode,\n          provider: 'claude',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Generic Claude error\n    return new BaseSDKError(\n      message,\n      'CLAUDE_API_ERROR',\n      {\n        statusCode,\n        provider: 'claude',\n        requestId,\n        details: { originalError: error },\n        cause: error\n      }\n    );\n  }\n\n  private static fromGenericError(\n    error: any,\n    provider: ApiProvider,\n    requestId?: string\n  ): SDKError {\n    const statusCode = error.status || error.statusCode || 500;\n    const message = error.message || `${provider} API error`;\n\n    return new BaseSDKError(\n      message,\n      'API_ERROR',\n      {\n        statusCode,\n        provider,\n        requestId,\n        details: { originalError: error },\n        cause: error\n      }\n    );\n  }\n}\n\n/**\n * Retry Configuration and Logic\n */\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n  retryableErrors: string[];\n}\n\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 30000, // 30 seconds\n  backoffMultiplier: 2,\n  jitter: true,\n  retryableErrors: [\n    'RATE_LIMIT_EXCEEDED',\n    'NETWORK_ERROR',\n    'TIMEOUT',\n    'SERVER_ERROR',\n    'TEMPORARY_FAILURE'\n  ]\n};\n\nexport class RetryHandler {\n  private config: RetryConfig;\n\n  constructor(config: Partial<RetryConfig> = {}) {\n    this.config = { ...DEFAULT_RETRY_CONFIG, ...config };\n  }\n\n  /**\n   * Execute a function with retry logic\n   */\n  async execute<T>(\n    fn: () => Promise<T>,\n    context?: {\n      provider?: ApiProvider;\n      requestId?: string;\n      operation?: string;\n    }\n  ): Promise<T> {\n    let lastError: SDKError | null = null;\n    let attempt = 0;\n\n    while (attempt <= this.config.maxRetries) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error instanceof BaseSDKError \n          ? error \n          : this.convertToSDKError(error, context?.provider);\n\n        // Don't retry on last attempt\n        if (attempt === this.config.maxRetries) {\n          break;\n        }\n\n        // Check if error is retryable\n        if (!this.isRetryableError(lastError)) {\n          break;\n        }\n\n        // Calculate delay for next attempt\n        const delay = this.calculateDelay(attempt, lastError);\n        \n        console.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms`, {\n          error: lastError.code,\n          provider: context?.provider,\n          requestId: context?.requestId,\n          operation: context?.operation\n        });\n\n        await this.sleep(delay);\n        attempt++;\n      }\n    }\n\n    // All attempts failed, throw the last error\n    throw lastError;\n  }\n\n  /**\n   * Check if an error should trigger a retry\n   */\n  private isRetryableError(error: SDKError): boolean {\n    // Don't retry authentication or validation errors\n    if (error.code === 'AUTHENTICATION_FAILED' || error.code === 'VALIDATION_ERROR') {\n      return false;\n    }\n\n    // Retry rate limit errors\n    if (error.code === 'RATE_LIMIT_EXCEEDED') {\n      return true;\n    }\n\n    // Retry server errors (5xx)\n    if (error.statusCode && error.statusCode >= 500) {\n      return true;\n    }\n\n    // Retry network/timeout errors\n    if (this.config.retryableErrors.includes(error.code)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate exponential backoff delay with jitter\n   */\n  private calculateDelay(attempt: number, error: SDKError): number {\n    // Use retry-after header if available (rate limit errors)\n    if (error instanceof SDKRateLimitError && error.retryAfter) {\n      return error.retryAfter * 1000; // Convert seconds to milliseconds\n    }\n\n    // Exponential backoff\n    let delay = this.config.baseDelay * Math.pow(this.config.backoffMultiplier, attempt);\n    \n    // Cap at max delay\n    delay = Math.min(delay, this.config.maxDelay);\n\n    // Add jitter to avoid thundering herd\n    if (this.config.jitter) {\n      delay = delay * (0.5 + Math.random() * 0.5);\n    }\n\n    return Math.floor(delay);\n  }\n\n  /**\n   * Convert generic error to SDK error\n   */\n  private convertToSDKError(error: any, provider?: ApiProvider): SDKError {\n    if (error instanceof BaseSDKError) {\n      return error;\n    }\n\n    // Network/timeout errors\n    if (error.code === 'ECONNRESET' || error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n      return new BaseSDKError(\n        `Network error: ${error.message}`,\n        'NETWORK_ERROR',\n        { provider, cause: error }\n      );\n    }\n\n    // Generic error\n    return new BaseSDKError(\n      error.message || 'Unknown error',\n      'UNKNOWN_ERROR',\n      { provider, cause: error }\n    );\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Circuit Breaker Pattern Implementation\n */\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  recoveryTimeout: number;\n  monitoringPeriod: number;\n}\n\nexport enum CircuitState {\n  CLOSED = 'closed',\n  OPEN = 'open',\n  HALF_OPEN = 'half_open'\n}\n\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failures: number = 0;\n  private lastFailureTime: number = 0;\n  private nextAttempt: number = 0;\n  private config: CircuitBreakerConfig;\n\n  constructor(config: Partial<CircuitBreakerConfig> = {}) {\n    this.config = {\n      failureThreshold: 5,\n      recoveryTimeout: 60000, // 1 minute\n      monitoringPeriod: 60000, // 1 minute\n      ...config\n    };\n  }\n\n  /**\n   * Execute function through circuit breaker\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttempt) {\n        throw new BaseSDKError(\n          'Circuit breaker is OPEN - too many recent failures',\n          'CIRCUIT_BREAKER_OPEN'\n        );\n      } else {\n        this.state = CircuitState.HALF_OPEN;\n      }\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failures = 0;\n    this.state = CircuitState.CLOSED;\n  }\n\n  private onFailure(): void {\n    this.failures++;\n    this.lastFailureTime = Date.now();\n\n    if (this.failures >= this.config.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.nextAttempt = Date.now() + this.config.recoveryTimeout;\n    }\n  }\n\n  /**\n   * Get current circuit breaker status\n   */\n  getStatus(): {\n    state: CircuitState;\n    failures: number;\n    lastFailureTime: number;\n    nextAttempt: number;\n  } {\n    return {\n      state: this.state,\n      failures: this.failures,\n      lastFailureTime: this.lastFailureTime,\n      nextAttempt: this.nextAttempt\n    };\n  }\n}\n\n/**\n * Request timeout wrapper\n */\nexport function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  context?: { operation?: string; provider?: ApiProvider }\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<never>((_, reject) => {\n      setTimeout(() => {\n        reject(new BaseSDKError(\n          `Operation timed out after ${timeoutMs}ms`,\n          'TIMEOUT',\n          {\n            provider: context?.provider,\n            details: { timeoutMs, operation: context?.operation }\n          }\n        ));\n      }, timeoutMs);\n    })\n  ]);\n}\n\n/**\n * Utility function to sanitize errors for logging\n */\nexport function sanitizeErrorForLogging(error: any): Record<string, any> {\n  const sanitized: Record<string, any> = {\n    name: error.name || 'Error',\n    message: error.message || 'Unknown error',\n    code: error.code,\n    statusCode: error.statusCode,\n    provider: error.provider,\n    requestId: error.requestId\n  };\n\n  // Remove sensitive information\n  if (error.details) {\n    sanitized.details = { ...error.details };\n    \n    // Remove API keys\n    if (sanitized.details.apiKey) {\n      sanitized.details.apiKey = '[REDACTED]';\n    }\n    \n    // Remove authorization headers\n    if (sanitized.details.headers?.authorization) {\n      sanitized.details.headers.authorization = '[REDACTED]';\n    }\n  }\n\n  return sanitized;\n}","/**\n * Base Provider Interface and Abstract Implementation\n * \n * Defines the unified interface that all AI providers must implement\n */\n\nimport type {\n  ApiProvider,\n  ChatCompletionRequest,\n  ChatCompletionResponse,\n  ChatCompletionChunk,\n  ImageGenerationRequest,\n  ImageGenerationResponse,\n  ProviderConfig,\n  ProviderCapabilities,\n  SDKError,\n  RequestMetrics,\n  Usage\n} from '../types';\n\nimport { RetryHandler, CircuitBreaker, withTimeout } from '../utils/errors';\n\nexport interface BaseProviderOptions {\n  apiKey?: string;\n  baseURL?: string;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n  userAgent?: string;\n  debug?: boolean;\n}\n\n/**\n * Abstract base class for all AI providers\n */\nexport abstract class BaseProvider {\n  protected readonly provider: ApiProvider;\n  protected readonly config: ProviderConfig;\n  protected readonly retryHandler: RetryHandler;\n  protected readonly circuitBreaker: CircuitBreaker;\n\n  constructor(provider: ApiProvider, config: ProviderConfig) {\n    this.provider = provider;\n    this.config = config;\n    this.retryHandler = new RetryHandler({\n      maxRetries: config.maxRetries || 3,\n      baseDelay: config.retryDelay || 1000\n    });\n    this.circuitBreaker = new CircuitBreaker();\n  }\n\n  /**\n   * Provider capabilities - must be implemented by each provider\n   */\n  abstract getCapabilities(): ProviderCapabilities;\n\n  /**\n   * Chat completion - core method all providers must implement\n   */\n  abstract chatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse>;\n\n  /**\n   * Streaming chat completion - optional, defaults to error\n   */\n  abstract streamChatCompletion(\n    request: ChatCompletionRequest\n  ): AsyncGenerator<ChatCompletionChunk, void, unknown>;\n\n  /**\n   * Image generation - optional, defaults to error if not supported\n   */\n  generateImages(request: ImageGenerationRequest): Promise<ImageGenerationResponse> {\n    throw new Error(`Image generation not supported by ${this.provider} provider`);\n  }\n\n  /**\n   * Provider-specific model validation\n   */\n  abstract validateModel(model: string): boolean;\n\n  /**\n   * Get available models for this provider\n   */\n  abstract getAvailableModels(): string[];\n\n  /**\n   * Estimate cost for a request\n   */\n  abstract estimateCost(request: ChatCompletionRequest): number;\n\n  /**\n   * Transform provider-specific response to unified format\n   */\n  protected abstract transformResponse(\n    response: any,\n    request: ChatCompletionRequest,\n    metrics: Partial<RequestMetrics>\n  ): ChatCompletionResponse;\n\n  /**\n   * Transform provider-specific streaming response to unified format\n   */\n  protected abstract transformStreamChunk(\n    chunk: any,\n    request: ChatCompletionRequest\n  ): ChatCompletionChunk | null;\n\n  /**\n   * Execute request with retry logic and circuit breaker\n   */\n  protected async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    context?: {\n      requestId?: string;\n      operation?: string;\n    }\n  ): Promise<T> {\n    const requestId = context?.requestId || this.generateRequestId();\n    \n    return this.circuitBreaker.execute(async () => {\n      return this.retryHandler.execute(fn, {\n        provider: this.provider,\n        requestId,\n        operation: context?.operation\n      });\n    });\n  }\n\n  /**\n   * Execute request with timeout\n   */\n  protected async executeWithTimeout<T>(\n    promise: Promise<T>,\n    operation: string\n  ): Promise<T> {\n    const timeout = this.config.timeout || 30000; // 30 seconds default\n    \n    return withTimeout(promise, timeout, {\n      operation,\n      provider: this.provider\n    });\n  }\n\n  /**\n   * Create request metrics for tracking\n   */\n  protected createRequestMetrics(\n    requestId: string,\n    model: string,\n    startTime: number\n  ): Partial<RequestMetrics> {\n    return {\n      requestId,\n      provider: this.provider,\n      model,\n      startTime,\n      endTime: 0,\n      tokens: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0, estimated_cost: 0 },\n      cost: 0,\n      success: false\n    };\n  }\n\n  /**\n   * Finalize request metrics\n   */\n  protected finalizeMetrics(\n    metrics: Partial<RequestMetrics>,\n    usage: Usage,\n    success: boolean,\n    error?: SDKError\n  ): RequestMetrics {\n    return {\n      ...metrics,\n      endTime: Date.now(),\n      tokens: usage,\n      cost: usage.estimated_cost,\n      success,\n      error\n    } as RequestMetrics;\n  }\n\n  /**\n   * Generate unique request ID\n   */\n  protected generateRequestId(): string {\n    return `${this.provider}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Validate API key format for this provider\n   */\n  protected abstract validateApiKey(apiKey: string): boolean;\n\n  /**\n   * Get default headers for requests\n   */\n  protected getDefaultHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      'User-Agent': this.config.userAgent || `ai-marketplace-sdk/0.1.0 (${this.provider})`\n    };\n\n    if (this.config.apiKey) {\n      headers['Authorization'] = this.getAuthHeader(this.config.apiKey);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Get provider-specific authorization header\n   */\n  protected abstract getAuthHeader(apiKey: string): string;\n\n  /**\n   * Health check for the provider\n   */\n  async healthCheck(): Promise<{\n    provider: ApiProvider;\n    healthy: boolean;\n    latency?: number;\n    error?: string;\n    capabilities: ProviderCapabilities;\n    circuitBreakerStatus: any;\n  }> {\n    const startTime = Date.now();\n    \n    try {\n      // Simple test request to verify provider is accessible\n      await this.executeWithTimeout(\n        this.testConnection(),\n        'health_check'\n      );\n\n      return {\n        provider: this.provider,\n        healthy: true,\n        latency: Date.now() - startTime,\n        capabilities: this.getCapabilities(),\n        circuitBreakerStatus: this.circuitBreaker.getStatus()\n      };\n    } catch (error) {\n      return {\n        provider: this.provider,\n        healthy: false,\n        latency: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        capabilities: this.getCapabilities(),\n        circuitBreakerStatus: this.circuitBreaker.getStatus()\n      };\n    }\n  }\n\n  /**\n   * Test connection to provider - should be implemented by each provider\n   */\n  protected abstract testConnection(): Promise<void>;\n\n  /**\n   * Get provider configuration (without sensitive data)\n   */\n  getConfig(): Omit<ProviderConfig, 'apiKey'> {\n    const { apiKey, ...safeConfig } = this.config;\n    return safeConfig;\n  }\n\n  /**\n   * Update provider configuration\n   */\n  updateConfig(updates: Partial<BaseProviderOptions>): void {\n    Object.assign(this.config, updates);\n  }\n}\n\n/**\n * Provider factory interface\n */\nexport interface ProviderFactory {\n  create(config: ProviderConfig): BaseProvider;\n  supports(provider: ApiProvider): boolean;\n}\n\n/**\n * Provider registry for managing multiple providers\n */\nexport class ProviderRegistry {\n  private factories = new Map<ApiProvider, ProviderFactory>();\n  private instances = new Map<string, BaseProvider>();\n\n  /**\n   * Register a provider factory\n   */\n  register(provider: ApiProvider, factory: ProviderFactory): void {\n    this.factories.set(provider, factory);\n  }\n\n  /**\n   * Get or create a provider instance\n   */\n  getProvider(config: ProviderConfig): BaseProvider {\n    const key = `${config.provider}-${config.model}`;\n    \n    if (this.instances.has(key)) {\n      return this.instances.get(key)!;\n    }\n\n    const factory = this.factories.get(config.provider);\n    if (!factory) {\n      throw new Error(`No factory registered for provider: ${config.provider}`);\n    }\n\n    const instance = factory.create(config);\n    this.instances.set(key, instance);\n    return instance;\n  }\n\n  /**\n   * Get all registered providers\n   */\n  getRegisteredProviders(): ApiProvider[] {\n    return Array.from(this.factories.keys());\n  }\n\n  /**\n   * Check if provider is supported\n   */\n  supports(provider: ApiProvider): boolean {\n    return this.factories.has(provider);\n  }\n\n  /**\n   * Clear all cached instances\n   */\n  clearCache(): void {\n    this.instances.clear();\n  }\n\n  /**\n   * Health check all providers\n   */\n  async healthCheckAll(): Promise<Record<string, any>> {\n    const results: Record<string, any> = {};\n    \n    for (const [provider, factory] of this.factories) {\n      try {\n        // Create a test instance with minimal config\n        const testInstance = factory.create({\n          provider,\n          model: 'test',\n          apiKey: 'test'\n        });\n        \n        results[provider] = await testInstance.healthCheck();\n      } catch (error) {\n        results[provider] = {\n          provider,\n          healthy: false,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        };\n      }\n    }\n\n    return results;\n  }\n}\n\n// Global provider registry instance\nexport const providerRegistry = new ProviderRegistry();","/**\n * Chat Module - Unified Chat Interface\n * \n * Provides high-level chat interface with provider abstraction and intelligent routing\n */\n\nimport type {\n  ChatCompletionRequest,\n  ChatCompletionResponse,\n  ChatCompletionChunk,\n  ProviderConfig,\n  ProviderConstraints,\n  ProviderSelection,\n  Message,\n  Tool\n} from '../types';\n\nimport { providerRegistry } from '../providers/base';\nimport { BaseSDKError } from '../utils/errors';\n\nexport interface ChatOptions {\n  provider?: ProviderConfig;\n  constraints?: ProviderConstraints;\n  enableAutoRetry?: boolean;\n  enableFallback?: boolean;\n  trackUsage?: boolean;\n}\n\n/**\n * High-level Chat interface with provider abstraction\n */\nexport class Chat {\n  private defaultProvider?: ProviderConfig;\n  private options: ChatOptions;\n\n  constructor(options: ChatOptions = {}) {\n    this.options = {\n      enableAutoRetry: true,\n      enableFallback: true,\n      trackUsage: true,\n      ...options\n    };\n    \n    this.defaultProvider = options.provider;\n  }\n\n  /**\n   * Complete a chat conversation\n   */\n  async complete(\n    request: ChatCompletionRequest,\n    options?: Partial<ChatOptions>\n  ): Promise<ChatCompletionResponse> {\n    const mergedOptions = { ...this.options, ...options };\n    \n    // Select optimal provider\n    const providerConfig = await this.selectProvider(request, mergedOptions);\n    \n    // Get provider instance\n    const provider = providerRegistry.getProvider(providerConfig);\n    \n    try {\n      return await provider.chatCompletion(request);\n    } catch (error) {\n      // Handle fallback if enabled\n      if (mergedOptions.enableFallback && this.shouldFallback(error)) {\n        return this.executeWithFallback(request, providerConfig, mergedOptions);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Stream a chat conversation\n   */\n  async* stream(\n    request: ChatCompletionRequest,\n    options?: Partial<ChatOptions>\n  ): AsyncGenerator<ChatCompletionChunk, void, unknown> {\n    const mergedOptions = { ...this.options, ...options };\n    \n    // Select optimal provider\n    const providerConfig = await this.selectProvider(request, mergedOptions);\n    \n    // Get provider instance\n    const provider = providerRegistry.getProvider(providerConfig);\n    \n    try {\n      yield* provider.streamChatCompletion(request);\n    } catch (error) {\n      // Fallback for streaming is more complex, for now just throw\n      throw error;\n    }\n  }\n\n  /**\n   * Simple text completion (convenience method)\n   */\n  async ask(\n    message: string,\n    options?: {\n      system?: string;\n      temperature?: number;\n      maxTokens?: number;\n    } & Partial<ChatOptions>\n  ): Promise<string> {\n    const messages: Message[] = [];\n    \n    if (options?.system) {\n      messages.push({ role: 'system', content: options.system });\n    }\n    \n    messages.push({ role: 'user', content: message });\n\n    const request: ChatCompletionRequest = {\n      messages,\n      ...(options?.temperature && { temperature: options.temperature }),\n      ...(options?.maxTokens && { max_tokens: options.maxTokens })\n    };\n\n    const response = await this.complete(request, options);\n    return response.choices[0]?.message.content || '';\n  }\n\n  /**\n   * Chat with conversation history\n   */\n  async chat(\n    messages: Message[],\n    options?: {\n      temperature?: number;\n      maxTokens?: number;\n      tools?: Tool[];\n    } & Partial<ChatOptions>\n  ): Promise<ChatCompletionResponse> {\n    const request: ChatCompletionRequest = {\n      messages,\n      ...(options?.temperature && { temperature: options.temperature }),\n      ...(options?.maxTokens && { max_tokens: options.maxTokens }),\n      ...(options?.tools && { tools: options.tools })\n    };\n\n    return this.complete(request, options);\n  }\n\n  /**\n   * Create a conversation instance for stateful chat\n   */\n  conversation(options?: {\n    system?: string;\n    temperature?: number;\n    maxTokens?: number;\n  } & Partial<ChatOptions>): Conversation {\n    return new Conversation(this, options);\n  }\n\n  /**\n   * Select optimal provider based on request and constraints\n   */\n  private async selectProvider(\n    request: ChatCompletionRequest,\n    options: ChatOptions\n  ): Promise<ProviderConfig> {\n    // Use explicit provider if specified\n    if (options.provider) {\n      return options.provider;\n    }\n\n    // Use default provider if no constraints\n    if (this.defaultProvider && !options.constraints) {\n      return this.defaultProvider;\n    }\n\n    // Implement intelligent provider selection\n    return this.intelligentProviderSelection(request, options.constraints);\n  }\n\n  /**\n   * Intelligent provider selection based on constraints and request characteristics\n   */\n  private async intelligentProviderSelection(\n    request: ChatCompletionRequest,\n    constraints?: ProviderConstraints\n  ): Promise<ProviderConfig> {\n    const supportedProviders = providerRegistry.getRegisteredProviders();\n    const candidates: ProviderSelection[] = [];\n\n    for (const provider of supportedProviders) {\n      // Skip excluded providers\n      if (constraints?.excludeProviders?.includes(provider)) {\n        continue;\n      }\n\n      // Get provider instance for evaluation\n      const config: ProviderConfig = {\n        provider,\n        model: this.getDefaultModel(provider),\n        apiKey: '' // Will be resolved later\n      };\n\n      const providerInstance = providerRegistry.getProvider(config);\n      const capabilities = providerInstance.getCapabilities();\n\n      // Check required capabilities\n      if (constraints?.requiredCapabilities) {\n        const hasRequired = constraints.requiredCapabilities.every(\n          cap => capabilities[cap] === true\n        );\n        if (!hasRequired) continue;\n      }\n\n      // Estimate cost and quality\n      const estimatedCost = providerInstance.estimateCost(request);\n      const estimatedLatency = this.estimateLatency(provider);\n      const qualityScore = this.calculateQualityScore(provider, request);\n\n      // Apply constraints\n      if (constraints?.maxCost && estimatedCost > constraints.maxCost) {\n        continue;\n      }\n      if (constraints?.maxLatency && estimatedLatency > constraints.maxLatency) {\n        continue;\n      }\n      if (constraints?.qualityThreshold && qualityScore < constraints.qualityThreshold) {\n        continue;\n      }\n\n      candidates.push({\n        provider,\n        model: config.model,\n        estimatedCost,\n        estimatedLatency,\n        qualityScore,\n        reasoning: this.generateSelectionReasoning(provider, estimatedCost, qualityScore)\n      });\n    }\n\n    if (candidates.length === 0) {\n      throw new BaseSDKError(\n        'No providers meet the specified constraints',\n        'NO_SUITABLE_PROVIDER',\n        { details: { constraints } }\n      );\n    }\n\n    // Select best candidate (optimize for cost/quality ratio)\n    const bestCandidate = candidates.reduce((best, current) => {\n      const bestScore = best.qualityScore / best.estimatedCost;\n      const currentScore = current.qualityScore / current.estimatedCost;\n      return currentScore > bestScore ? current : best;\n    });\n\n    // Check for preferred providers\n    if (constraints?.preferredProviders) {\n      const preferredCandidate = candidates.find(c => \n        constraints.preferredProviders!.includes(c.provider)\n      );\n      if (preferredCandidate) {\n        return {\n          provider: preferredCandidate.provider,\n          model: preferredCandidate.model,\n          apiKey: '' // Will be resolved later\n        };\n      }\n    }\n\n    return {\n      provider: bestCandidate.provider,\n      model: bestCandidate.model,\n      apiKey: '' // Will be resolved later\n    };\n  }\n\n  /**\n   * Execute request with fallback providers\n   */\n  private async executeWithFallback(\n    request: ChatCompletionRequest,\n    failedProvider: ProviderConfig,\n    options: ChatOptions\n  ): Promise<ChatCompletionResponse> {\n    const fallbackProviders = this.getFallbackProviders(failedProvider);\n    \n    for (const provider of fallbackProviders) {\n      try {\n        const providerInstance = providerRegistry.getProvider(provider);\n        return await providerInstance.chatCompletion(request);\n      } catch (error) {\n        // Continue to next fallback\n        continue;\n      }\n    }\n\n    throw new BaseSDKError(\n      'All fallback providers failed',\n      'ALL_PROVIDERS_FAILED',\n      { details: { originalProvider: failedProvider.provider } }\n    );\n  }\n\n  /**\n   * Determine if error should trigger fallback\n   */\n  private shouldFallback(error: any): boolean {\n    // Fallback on rate limits, server errors, but not auth/validation errors\n    if (error.code === 'RATE_LIMIT_EXCEEDED') return true;\n    if (error.statusCode && error.statusCode >= 500) return true;\n    if (error.code === 'NETWORK_ERROR') return true;\n    return false;\n  }\n\n  /**\n   * Get fallback providers for a failed provider\n   */\n  private getFallbackProviders(failedProvider: ProviderConfig): ProviderConfig[] {\n    const fallbackMap: Record<string, string[]> = {\n      'openai': ['claude'],\n      'claude': ['openai'],\n      'google': ['openai', 'claude'],\n      'azure': ['openai', 'claude'],\n      'cohere': ['openai', 'claude'],\n      'huggingface': ['openai', 'claude']\n    };\n\n    const fallbacks = fallbackMap[failedProvider.provider] || ['openai'];\n    return fallbacks.map(provider => ({\n      provider: provider as any,\n      model: this.getDefaultModel(provider as any),\n      apiKey: '' // Will be resolved later\n    }));\n  }\n\n  /**\n   * Get default model for provider\n   */\n  private getDefaultModel(provider: string): string {\n    const defaultModels: Record<string, string> = {\n      'openai': 'gpt-4o',\n      'claude': 'claude-3-5-sonnet-20241022',\n      'google': 'gemini-pro',\n      'azure': 'gpt-4',\n      'cohere': 'command-r-plus',\n      'huggingface': 'meta-llama/Llama-2-70b-chat-hf'\n    };\n    return defaultModels[provider] || 'gpt-4o';\n  }\n\n  /**\n   * Estimate latency for provider (placeholder implementation)\n   */\n  private estimateLatency(provider: string): number {\n    const latencyMap: Record<string, number> = {\n      'openai': 2000,\n      'claude': 3000,\n      'google': 1500,\n      'azure': 2500,\n      'cohere': 2000,\n      'huggingface': 4000\n    };\n    return latencyMap[provider] || 2000;\n  }\n\n  /**\n   * Calculate quality score for provider (placeholder implementation)\n   */\n  private calculateQualityScore(provider: string, request: ChatCompletionRequest): number {\n    // Simple quality scoring based on provider capabilities\n    const qualityMap: Record<string, number> = {\n      'openai': 0.9,\n      'claude': 0.95,\n      'google': 0.8,\n      'azure': 0.9,\n      'cohere': 0.7,\n      'huggingface': 0.6\n    };\n    return qualityMap[provider] || 0.5;\n  }\n\n  /**\n   * Generate reasoning for provider selection\n   */\n  private generateSelectionReasoning(provider: string, cost: number, quality: number): string {\n    return `Selected ${provider} for optimal cost/quality ratio (cost: $${cost.toFixed(4)}, quality: ${quality.toFixed(2)})`;\n  }\n}\n\n/**\n * Stateful conversation class\n */\nexport class Conversation {\n  private messages: Message[] = [];\n  private chat: Chat;\n  private options: any;\n\n  constructor(chat: Chat, options: any = {}) {\n    this.chat = chat;\n    this.options = options;\n\n    // Add system message if provided\n    if (options.system) {\n      this.messages.push({ role: 'system', content: options.system });\n    }\n  }\n\n  /**\n   * Send a message and get response\n   */\n  async say(message: string): Promise<string> {\n    this.messages.push({ role: 'user', content: message });\n\n    const response = await this.chat.chat(this.messages, this.options);\n    const assistantMessage = response.choices[0]?.message.content || '';\n\n    this.messages.push({ role: 'assistant', content: assistantMessage });\n\n    return assistantMessage;\n  }\n\n  /**\n   * Get conversation history\n   */\n  getHistory(): Message[] {\n    return [...this.messages];\n  }\n\n  /**\n   * Clear conversation history (keeping system message)\n   */\n  clear(): void {\n    const systemMessage = this.messages.find(m => m.role === 'system');\n    this.messages = systemMessage ? [systemMessage] : [];\n  }\n\n  /**\n   * Get conversation summary\n   */\n  async summarize(): Promise<string> {\n    if (this.messages.length < 3) {\n      return 'Conversation too short to summarize';\n    }\n\n    const summaryRequest: Message[] = [\n      { role: 'system', content: 'Summarize the following conversation concisely.' },\n      { role: 'user', content: JSON.stringify(this.messages) }\n    ];\n\n    const response = await this.chat.chat(summaryRequest, { ...this.options, maxTokens: 200 });\n    return response.choices[0]?.message.content || 'Unable to generate summary';\n  }\n}\n\n/**\n * Convenience function to create a Chat instance\n */\nexport function createChat(options?: ChatOptions): Chat {\n  return new Chat(options);\n}\n\n/**\n * Quick helper functions\n */\nexport async function ask(\n  message: string,\n  options?: {\n    provider?: ProviderConfig;\n    system?: string;\n    temperature?: number;\n  }\n): Promise<string> {\n  const chat = new Chat({ provider: options?.provider });\n  return chat.ask(message, options);\n}\n\nexport async function chat(\n  messages: Message[],\n  options?: {\n    provider?: ProviderConfig;\n    temperature?: number;\n    tools?: Tool[];\n  }\n): Promise<ChatCompletionResponse> {\n  const chatInstance = new Chat({ provider: options?.provider });\n  return chatInstance.chat(messages, options);\n}"]}