{"version":3,"sources":["../../src/utils/errors.ts","../../src/providers/base.ts","../../src/images/index.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * Error Handling and Retry Mechanisms\n * \n * Implements exponential backoff, circuit breaker patterns, and provider-specific error handling\n */\n\nimport type { \n  SDKError, \n  RateLimitError, \n  AuthenticationError, \n  ValidationError, \n  ApiProvider,\n  RequestMetrics \n} from '../types';\n\n/**\n * Custom SDK Error Classes\n */\nexport class BaseSDKError extends Error implements SDKError {\n  public readonly code: string;\n  public readonly statusCode?: number;\n  public readonly provider?: ApiProvider;\n  public readonly requestId?: string;\n  public readonly details?: Record<string, any>;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      statusCode?: number;\n      provider?: ApiProvider;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, { cause: options?.cause });\n    this.name = this.constructor.name;\n    this.code = code;\n    this.statusCode = options?.statusCode;\n    this.provider = options?.provider;\n    this.requestId = options?.requestId;\n    this.details = options?.details;\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SDKRateLimitError extends BaseSDKError implements RateLimitError {\n  public readonly code = 'RATE_LIMIT_EXCEEDED';\n  public readonly retryAfter?: number;\n  public readonly limitType: 'requests' | 'tokens' | 'cost';\n\n  constructor(\n    message: string,\n    limitType: 'requests' | 'tokens' | 'cost',\n    options?: {\n      retryAfter?: number;\n      statusCode?: number;\n      provider?: ApiProvider;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, 'RATE_LIMIT_EXCEEDED', options);\n    this.limitType = limitType;\n    this.retryAfter = options?.retryAfter;\n  }\n}\n\nexport class SDKAuthenticationError extends BaseSDKError implements AuthenticationError {\n  public readonly code = 'AUTHENTICATION_FAILED';\n  public readonly provider: ApiProvider;\n\n  constructor(\n    message: string,\n    provider: ApiProvider,\n    options?: {\n      statusCode?: number;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, 'AUTHENTICATION_FAILED', { ...options, provider });\n    this.provider = provider;\n  }\n}\n\nexport class SDKValidationError extends BaseSDKError implements ValidationError {\n  public readonly code = 'VALIDATION_ERROR';\n  public readonly field: string;\n  public readonly value: any;\n\n  constructor(\n    message: string,\n    field: string,\n    value: any,\n    options?: {\n      statusCode?: number;\n      provider?: ApiProvider;\n      requestId?: string;\n      details?: Record<string, any>;\n      cause?: Error;\n    }\n  ) {\n    super(message, 'VALIDATION_ERROR', options);\n    this.field = field;\n    this.value = value;\n  }\n}\n\n/**\n * Error Factory - Creates appropriate error types from provider responses\n */\nexport class ErrorFactory {\n  static fromProviderError(\n    error: any,\n    provider: ApiProvider,\n    requestId?: string\n  ): SDKError {\n    // OpenAI error handling\n    if (provider === 'openai') {\n      return this.fromOpenAIError(error, requestId);\n    }\n\n    // Claude error handling\n    if (provider === 'claude') {\n      return this.fromClaudeError(error, requestId);\n    }\n\n    // Generic error handling\n    return this.fromGenericError(error, provider, requestId);\n  }\n\n  private static fromOpenAIError(error: any, requestId?: string): SDKError {\n    const statusCode = error.status || error.statusCode || 500;\n    const message = error.message || error.error?.message || 'OpenAI API error';\n\n    // Rate limiting\n    if (statusCode === 429) {\n      const retryAfter = error.headers?.['retry-after'] \n        ? parseInt(error.headers['retry-after'], 10) \n        : undefined;\n      \n      return new SDKRateLimitError(\n        message,\n        'requests',\n        {\n          retryAfter,\n          statusCode,\n          provider: 'openai',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Authentication errors\n    if (statusCode === 401) {\n      return new SDKAuthenticationError(\n        message,\n        'openai',\n        {\n          statusCode,\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Validation errors\n    if (statusCode === 400) {\n      return new SDKValidationError(\n        message,\n        error.error?.param || 'unknown',\n        error.error?.code || 'unknown',\n        {\n          statusCode,\n          provider: 'openai',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Generic OpenAI error\n    return new BaseSDKError(\n      message,\n      'OPENAI_API_ERROR',\n      {\n        statusCode,\n        provider: 'openai',\n        requestId,\n        details: { originalError: error },\n        cause: error\n      }\n    );\n  }\n\n  private static fromClaudeError(error: any, requestId?: string): SDKError {\n    const statusCode = error.status || error.statusCode || 500;\n    const message = error.message || error.error?.message || 'Claude API error';\n\n    // Rate limiting\n    if (statusCode === 429) {\n      const retryAfter = error.headers?.['retry-after'] \n        ? parseInt(error.headers['retry-after'], 10) \n        : undefined;\n      \n      return new SDKRateLimitError(\n        message,\n        'requests',\n        {\n          retryAfter,\n          statusCode,\n          provider: 'claude',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Authentication errors\n    if (statusCode === 401) {\n      return new SDKAuthenticationError(\n        message,\n        'claude',\n        {\n          statusCode,\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Validation errors\n    if (statusCode === 400) {\n      return new SDKValidationError(\n        message,\n        error.error?.param || 'unknown',\n        error.error?.code || 'unknown',\n        {\n          statusCode,\n          provider: 'claude',\n          requestId,\n          details: { originalError: error }\n        }\n      );\n    }\n\n    // Generic Claude error\n    return new BaseSDKError(\n      message,\n      'CLAUDE_API_ERROR',\n      {\n        statusCode,\n        provider: 'claude',\n        requestId,\n        details: { originalError: error },\n        cause: error\n      }\n    );\n  }\n\n  private static fromGenericError(\n    error: any,\n    provider: ApiProvider,\n    requestId?: string\n  ): SDKError {\n    const statusCode = error.status || error.statusCode || 500;\n    const message = error.message || `${provider} API error`;\n\n    return new BaseSDKError(\n      message,\n      'API_ERROR',\n      {\n        statusCode,\n        provider,\n        requestId,\n        details: { originalError: error },\n        cause: error\n      }\n    );\n  }\n}\n\n/**\n * Retry Configuration and Logic\n */\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n  retryableErrors: string[];\n}\n\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 30000, // 30 seconds\n  backoffMultiplier: 2,\n  jitter: true,\n  retryableErrors: [\n    'RATE_LIMIT_EXCEEDED',\n    'NETWORK_ERROR',\n    'TIMEOUT',\n    'SERVER_ERROR',\n    'TEMPORARY_FAILURE'\n  ]\n};\n\nexport class RetryHandler {\n  private config: RetryConfig;\n\n  constructor(config: Partial<RetryConfig> = {}) {\n    this.config = { ...DEFAULT_RETRY_CONFIG, ...config };\n  }\n\n  /**\n   * Execute a function with retry logic\n   */\n  async execute<T>(\n    fn: () => Promise<T>,\n    context?: {\n      provider?: ApiProvider;\n      requestId?: string;\n      operation?: string;\n    }\n  ): Promise<T> {\n    let lastError: SDKError | null = null;\n    let attempt = 0;\n\n    while (attempt <= this.config.maxRetries) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error instanceof BaseSDKError \n          ? error \n          : this.convertToSDKError(error, context?.provider);\n\n        // Don't retry on last attempt\n        if (attempt === this.config.maxRetries) {\n          break;\n        }\n\n        // Check if error is retryable\n        if (!this.isRetryableError(lastError)) {\n          break;\n        }\n\n        // Calculate delay for next attempt\n        const delay = this.calculateDelay(attempt, lastError);\n        \n        console.warn(`Attempt ${attempt + 1} failed, retrying in ${delay}ms`, {\n          error: lastError.code,\n          provider: context?.provider,\n          requestId: context?.requestId,\n          operation: context?.operation\n        });\n\n        await this.sleep(delay);\n        attempt++;\n      }\n    }\n\n    // All attempts failed, throw the last error\n    throw lastError;\n  }\n\n  /**\n   * Check if an error should trigger a retry\n   */\n  private isRetryableError(error: SDKError): boolean {\n    // Don't retry authentication or validation errors\n    if (error.code === 'AUTHENTICATION_FAILED' || error.code === 'VALIDATION_ERROR') {\n      return false;\n    }\n\n    // Retry rate limit errors\n    if (error.code === 'RATE_LIMIT_EXCEEDED') {\n      return true;\n    }\n\n    // Retry server errors (5xx)\n    if (error.statusCode && error.statusCode >= 500) {\n      return true;\n    }\n\n    // Retry network/timeout errors\n    if (this.config.retryableErrors.includes(error.code)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate exponential backoff delay with jitter\n   */\n  private calculateDelay(attempt: number, error: SDKError): number {\n    // Use retry-after header if available (rate limit errors)\n    if (error instanceof SDKRateLimitError && error.retryAfter) {\n      return error.retryAfter * 1000; // Convert seconds to milliseconds\n    }\n\n    // Exponential backoff\n    let delay = this.config.baseDelay * Math.pow(this.config.backoffMultiplier, attempt);\n    \n    // Cap at max delay\n    delay = Math.min(delay, this.config.maxDelay);\n\n    // Add jitter to avoid thundering herd\n    if (this.config.jitter) {\n      delay = delay * (0.5 + Math.random() * 0.5);\n    }\n\n    return Math.floor(delay);\n  }\n\n  /**\n   * Convert generic error to SDK error\n   */\n  private convertToSDKError(error: any, provider?: ApiProvider): SDKError {\n    if (error instanceof BaseSDKError) {\n      return error;\n    }\n\n    // Network/timeout errors\n    if (error.code === 'ECONNRESET' || error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n      return new BaseSDKError(\n        `Network error: ${error.message}`,\n        'NETWORK_ERROR',\n        { provider, cause: error }\n      );\n    }\n\n    // Generic error\n    return new BaseSDKError(\n      error.message || 'Unknown error',\n      'UNKNOWN_ERROR',\n      { provider, cause: error }\n    );\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Circuit Breaker Pattern Implementation\n */\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  recoveryTimeout: number;\n  monitoringPeriod: number;\n}\n\nexport enum CircuitState {\n  CLOSED = 'closed',\n  OPEN = 'open',\n  HALF_OPEN = 'half_open'\n}\n\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failures: number = 0;\n  private lastFailureTime: number = 0;\n  private nextAttempt: number = 0;\n  private config: CircuitBreakerConfig;\n\n  constructor(config: Partial<CircuitBreakerConfig> = {}) {\n    this.config = {\n      failureThreshold: 5,\n      recoveryTimeout: 60000, // 1 minute\n      monitoringPeriod: 60000, // 1 minute\n      ...config\n    };\n  }\n\n  /**\n   * Execute function through circuit breaker\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttempt) {\n        throw new BaseSDKError(\n          'Circuit breaker is OPEN - too many recent failures',\n          'CIRCUIT_BREAKER_OPEN'\n        );\n      } else {\n        this.state = CircuitState.HALF_OPEN;\n      }\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failures = 0;\n    this.state = CircuitState.CLOSED;\n  }\n\n  private onFailure(): void {\n    this.failures++;\n    this.lastFailureTime = Date.now();\n\n    if (this.failures >= this.config.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.nextAttempt = Date.now() + this.config.recoveryTimeout;\n    }\n  }\n\n  /**\n   * Get current circuit breaker status\n   */\n  getStatus(): {\n    state: CircuitState;\n    failures: number;\n    lastFailureTime: number;\n    nextAttempt: number;\n  } {\n    return {\n      state: this.state,\n      failures: this.failures,\n      lastFailureTime: this.lastFailureTime,\n      nextAttempt: this.nextAttempt\n    };\n  }\n}\n\n/**\n * Request timeout wrapper\n */\nexport function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  context?: { operation?: string; provider?: ApiProvider }\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<never>((_, reject) => {\n      setTimeout(() => {\n        reject(new BaseSDKError(\n          `Operation timed out after ${timeoutMs}ms`,\n          'TIMEOUT',\n          {\n            provider: context?.provider,\n            details: { timeoutMs, operation: context?.operation }\n          }\n        ));\n      }, timeoutMs);\n    })\n  ]);\n}\n\n/**\n * Utility function to sanitize errors for logging\n */\nexport function sanitizeErrorForLogging(error: any): Record<string, any> {\n  const sanitized: Record<string, any> = {\n    name: error.name || 'Error',\n    message: error.message || 'Unknown error',\n    code: error.code,\n    statusCode: error.statusCode,\n    provider: error.provider,\n    requestId: error.requestId\n  };\n\n  // Remove sensitive information\n  if (error.details) {\n    sanitized.details = { ...error.details };\n    \n    // Remove API keys\n    if (sanitized.details.apiKey) {\n      sanitized.details.apiKey = '[REDACTED]';\n    }\n    \n    // Remove authorization headers\n    if (sanitized.details.headers?.authorization) {\n      sanitized.details.headers.authorization = '[REDACTED]';\n    }\n  }\n\n  return sanitized;\n}","/**\n * Base Provider Interface and Abstract Implementation\n * \n * Defines the unified interface that all AI providers must implement\n */\n\nimport type {\n  ApiProvider,\n  ChatCompletionRequest,\n  ChatCompletionResponse,\n  ChatCompletionChunk,\n  ImageGenerationRequest,\n  ImageGenerationResponse,\n  ProviderConfig,\n  ProviderCapabilities,\n  SDKError,\n  RequestMetrics,\n  Usage\n} from '../types';\n\nimport { RetryHandler, CircuitBreaker, withTimeout } from '../utils/errors';\n\nexport interface BaseProviderOptions {\n  apiKey?: string;\n  baseURL?: string;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n  userAgent?: string;\n  debug?: boolean;\n}\n\n/**\n * Abstract base class for all AI providers\n */\nexport abstract class BaseProvider {\n  protected readonly provider: ApiProvider;\n  protected readonly config: ProviderConfig;\n  protected readonly retryHandler: RetryHandler;\n  protected readonly circuitBreaker: CircuitBreaker;\n\n  constructor(provider: ApiProvider, config: ProviderConfig) {\n    this.provider = provider;\n    this.config = config;\n    this.retryHandler = new RetryHandler({\n      maxRetries: config.maxRetries || 3,\n      baseDelay: config.retryDelay || 1000\n    });\n    this.circuitBreaker = new CircuitBreaker();\n  }\n\n  /**\n   * Provider capabilities - must be implemented by each provider\n   */\n  abstract getCapabilities(): ProviderCapabilities;\n\n  /**\n   * Chat completion - core method all providers must implement\n   */\n  abstract chatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse>;\n\n  /**\n   * Streaming chat completion - optional, defaults to error\n   */\n  abstract streamChatCompletion(\n    request: ChatCompletionRequest\n  ): AsyncGenerator<ChatCompletionChunk, void, unknown>;\n\n  /**\n   * Image generation - optional, defaults to error if not supported\n   */\n  generateImages(request: ImageGenerationRequest): Promise<ImageGenerationResponse> {\n    throw new Error(`Image generation not supported by ${this.provider} provider`);\n  }\n\n  /**\n   * Provider-specific model validation\n   */\n  abstract validateModel(model: string): boolean;\n\n  /**\n   * Get available models for this provider\n   */\n  abstract getAvailableModels(): string[];\n\n  /**\n   * Estimate cost for a request\n   */\n  abstract estimateCost(request: ChatCompletionRequest): number;\n\n  /**\n   * Transform provider-specific response to unified format\n   */\n  protected abstract transformResponse(\n    response: any,\n    request: ChatCompletionRequest,\n    metrics: Partial<RequestMetrics>\n  ): ChatCompletionResponse;\n\n  /**\n   * Transform provider-specific streaming response to unified format\n   */\n  protected abstract transformStreamChunk(\n    chunk: any,\n    request: ChatCompletionRequest\n  ): ChatCompletionChunk | null;\n\n  /**\n   * Execute request with retry logic and circuit breaker\n   */\n  protected async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    context?: {\n      requestId?: string;\n      operation?: string;\n    }\n  ): Promise<T> {\n    const requestId = context?.requestId || this.generateRequestId();\n    \n    return this.circuitBreaker.execute(async () => {\n      return this.retryHandler.execute(fn, {\n        provider: this.provider,\n        requestId,\n        operation: context?.operation\n      });\n    });\n  }\n\n  /**\n   * Execute request with timeout\n   */\n  protected async executeWithTimeout<T>(\n    promise: Promise<T>,\n    operation: string\n  ): Promise<T> {\n    const timeout = this.config.timeout || 30000; // 30 seconds default\n    \n    return withTimeout(promise, timeout, {\n      operation,\n      provider: this.provider\n    });\n  }\n\n  /**\n   * Create request metrics for tracking\n   */\n  protected createRequestMetrics(\n    requestId: string,\n    model: string,\n    startTime: number\n  ): Partial<RequestMetrics> {\n    return {\n      requestId,\n      provider: this.provider,\n      model,\n      startTime,\n      endTime: 0,\n      tokens: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0, estimated_cost: 0 },\n      cost: 0,\n      success: false\n    };\n  }\n\n  /**\n   * Finalize request metrics\n   */\n  protected finalizeMetrics(\n    metrics: Partial<RequestMetrics>,\n    usage: Usage,\n    success: boolean,\n    error?: SDKError\n  ): RequestMetrics {\n    return {\n      ...metrics,\n      endTime: Date.now(),\n      tokens: usage,\n      cost: usage.estimated_cost,\n      success,\n      error\n    } as RequestMetrics;\n  }\n\n  /**\n   * Generate unique request ID\n   */\n  protected generateRequestId(): string {\n    return `${this.provider}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Validate API key format for this provider\n   */\n  protected abstract validateApiKey(apiKey: string): boolean;\n\n  /**\n   * Get default headers for requests\n   */\n  protected getDefaultHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      'User-Agent': this.config.userAgent || `ai-marketplace-sdk/0.1.0 (${this.provider})`\n    };\n\n    if (this.config.apiKey) {\n      headers['Authorization'] = this.getAuthHeader(this.config.apiKey);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Get provider-specific authorization header\n   */\n  protected abstract getAuthHeader(apiKey: string): string;\n\n  /**\n   * Health check for the provider\n   */\n  async healthCheck(): Promise<{\n    provider: ApiProvider;\n    healthy: boolean;\n    latency?: number;\n    error?: string;\n    capabilities: ProviderCapabilities;\n    circuitBreakerStatus: any;\n  }> {\n    const startTime = Date.now();\n    \n    try {\n      // Simple test request to verify provider is accessible\n      await this.executeWithTimeout(\n        this.testConnection(),\n        'health_check'\n      );\n\n      return {\n        provider: this.provider,\n        healthy: true,\n        latency: Date.now() - startTime,\n        capabilities: this.getCapabilities(),\n        circuitBreakerStatus: this.circuitBreaker.getStatus()\n      };\n    } catch (error) {\n      return {\n        provider: this.provider,\n        healthy: false,\n        latency: Date.now() - startTime,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        capabilities: this.getCapabilities(),\n        circuitBreakerStatus: this.circuitBreaker.getStatus()\n      };\n    }\n  }\n\n  /**\n   * Test connection to provider - should be implemented by each provider\n   */\n  protected abstract testConnection(): Promise<void>;\n\n  /**\n   * Get provider configuration (without sensitive data)\n   */\n  getConfig(): Omit<ProviderConfig, 'apiKey'> {\n    const { apiKey, ...safeConfig } = this.config;\n    return safeConfig;\n  }\n\n  /**\n   * Update provider configuration\n   */\n  updateConfig(updates: Partial<BaseProviderOptions>): void {\n    Object.assign(this.config, updates);\n  }\n}\n\n/**\n * Provider factory interface\n */\nexport interface ProviderFactory {\n  create(config: ProviderConfig): BaseProvider;\n  supports(provider: ApiProvider): boolean;\n}\n\n/**\n * Provider registry for managing multiple providers\n */\nexport class ProviderRegistry {\n  private factories = new Map<ApiProvider, ProviderFactory>();\n  private instances = new Map<string, BaseProvider>();\n\n  /**\n   * Register a provider factory\n   */\n  register(provider: ApiProvider, factory: ProviderFactory): void {\n    this.factories.set(provider, factory);\n  }\n\n  /**\n   * Get or create a provider instance\n   */\n  getProvider(config: ProviderConfig): BaseProvider {\n    const key = `${config.provider}-${config.model}`;\n    \n    if (this.instances.has(key)) {\n      return this.instances.get(key)!;\n    }\n\n    const factory = this.factories.get(config.provider);\n    if (!factory) {\n      throw new Error(`No factory registered for provider: ${config.provider}`);\n    }\n\n    const instance = factory.create(config);\n    this.instances.set(key, instance);\n    return instance;\n  }\n\n  /**\n   * Get all registered providers\n   */\n  getRegisteredProviders(): ApiProvider[] {\n    return Array.from(this.factories.keys());\n  }\n\n  /**\n   * Check if provider is supported\n   */\n  supports(provider: ApiProvider): boolean {\n    return this.factories.has(provider);\n  }\n\n  /**\n   * Clear all cached instances\n   */\n  clearCache(): void {\n    this.instances.clear();\n  }\n\n  /**\n   * Health check all providers\n   */\n  async healthCheckAll(): Promise<Record<string, any>> {\n    const results: Record<string, any> = {};\n    \n    for (const [provider, factory] of this.factories) {\n      try {\n        // Create a test instance with minimal config\n        const testInstance = factory.create({\n          provider,\n          model: 'test',\n          apiKey: 'test'\n        });\n        \n        results[provider] = await testInstance.healthCheck();\n      } catch (error) {\n        results[provider] = {\n          provider,\n          healthy: false,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        };\n      }\n    }\n\n    return results;\n  }\n}\n\n// Global provider registry instance\nexport const providerRegistry = new ProviderRegistry();","/**\n * Images Module - Image Generation Interface\n * \n * Provides high-level image generation interface with provider abstraction\n */\n\nimport type {\n  ImageGenerationRequest,\n  ImageGenerationResponse,\n  ProviderConfig,\n  ProviderConstraints\n} from '../types';\n\nimport { providerRegistry } from '../providers/base';\nimport { BaseSDKError } from '../utils/errors';\n\nexport interface ImageOptions {\n  provider?: ProviderConfig;\n  constraints?: ProviderConstraints;\n  enableAutoRetry?: boolean;\n  enableFallback?: boolean;\n}\n\n/**\n * High-level Images interface with provider abstraction\n */\nexport class Images {\n  private defaultProvider?: ProviderConfig;\n  private options: ImageOptions;\n\n  constructor(options: ImageOptions = {}) {\n    this.options = {\n      enableAutoRetry: true,\n      enableFallback: true,\n      ...options\n    };\n    \n    this.defaultProvider = options.provider;\n  }\n\n  /**\n   * Generate images from text prompt\n   */\n  async generate(\n    request: ImageGenerationRequest,\n    options?: Partial<ImageOptions>\n  ): Promise<ImageGenerationResponse> {\n    const mergedOptions = { ...this.options, ...options };\n    \n    // Select optimal provider\n    const providerConfig = await this.selectProvider(request, mergedOptions);\n    \n    // Get provider instance\n    const provider = providerRegistry.getProvider(providerConfig);\n    \n    // Check if provider supports image generation\n    const capabilities = provider.getCapabilities();\n    if (!capabilities.images) {\n      throw new BaseSDKError(\n        `Provider ${providerConfig.provider} does not support image generation`,\n        'UNSUPPORTED_OPERATION',\n        { provider: providerConfig.provider }\n      );\n    }\n\n    try {\n      return await provider.generateImages(request);\n    } catch (error) {\n      // Handle fallback if enabled\n      if (mergedOptions.enableFallback && this.shouldFallback(error)) {\n        return this.executeWithFallback(request, providerConfig, mergedOptions);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a single image (convenience method)\n   */\n  async create(\n    prompt: string,\n    options?: {\n      size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';\n      quality?: 'standard' | 'hd';\n      style?: 'vivid' | 'natural';\n      model?: string;\n    } & Partial<ImageOptions>\n  ): Promise<string> {\n    const request: ImageGenerationRequest = {\n      prompt,\n      n: 1,\n      response_format: 'url',\n      ...(options?.size && { size: options.size }),\n      ...(options?.quality && { quality: options.quality }),\n      ...(options?.style && { style: options.style }),\n      ...(options?.model && { model: options.model })\n    };\n\n    const response = await this.generate(request, options);\n    \n    if (!response.data[0]?.url) {\n      throw new BaseSDKError(\n        'No image URL returned from provider',\n        'INVALID_RESPONSE'\n      );\n    }\n\n    return response.data[0].url;\n  }\n\n  /**\n   * Generate multiple images\n   */\n  async createBatch(\n    prompt: string,\n    count: number,\n    options?: {\n      size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';\n      quality?: 'standard' | 'hd';\n      style?: 'vivid' | 'natural';\n      model?: string;\n    } & Partial<ImageOptions>\n  ): Promise<string[]> {\n    if (count <= 0 || count > 10) {\n      throw new BaseSDKError(\n        'Image count must be between 1 and 10',\n        'VALIDATION_ERROR',\n        { details: { field: 'count', value: count } }\n      );\n    }\n\n    const request: ImageGenerationRequest = {\n      prompt,\n      n: count,\n      response_format: 'url',\n      ...(options?.size && { size: options.size }),\n      ...(options?.quality && { quality: options.quality }),\n      ...(options?.style && { style: options.style }),\n      ...(options?.model && { model: options.model })\n    };\n\n    const response = await this.generate(request, options);\n    \n    return response.data\n      .map(item => item.url)\n      .filter(url => url !== undefined) as string[];\n  }\n\n  /**\n   * Generate image variations (if supported by provider)\n   */\n  async createVariations(\n    originalImageUrl: string,\n    options?: {\n      n?: number;\n      size?: '256x256' | '512x512' | '1024x1024';\n      response_format?: 'url' | 'b64_json';\n    } & Partial<ImageOptions>\n  ): Promise<ImageGenerationResponse> {\n    // This would need to be implemented per provider\n    // For now, throw an error as it's not commonly supported\n    throw new BaseSDKError(\n      'Image variations not yet supported',\n      'UNSUPPORTED_OPERATION'\n    );\n  }\n\n  /**\n   * Get supported image sizes for current provider\n   */\n  getSupportedSizes(provider?: string): string[] {\n    const supportedSizes: Record<string, string[]> = {\n      'openai': ['256x256', '512x512', '1024x1024', '1792x1024', '1024x1792'],\n      'azure': ['256x256', '512x512', '1024x1024'],\n      // Add other providers as they support image generation\n    };\n\n    const providerName = provider || this.defaultProvider?.provider || 'openai';\n    return supportedSizes[providerName] || ['1024x1024'];\n  }\n\n  /**\n   * Estimate cost for image generation\n   */\n  async estimateCost(\n    request: ImageGenerationRequest,\n    provider?: string\n  ): Promise<number> {\n    const providerName = provider || this.defaultProvider?.provider || 'openai';\n    \n    // Cost estimation based on provider and request\n    const costPerImage: Record<string, number> = {\n      'openai': request.quality === 'hd' ? 0.08 : 0.04,\n      'azure': 0.04\n    };\n\n    const baseCost = costPerImage[providerName] || 0.04;\n    return baseCost * (request.n || 1);\n  }\n\n  /**\n   * Select optimal provider based on request and constraints\n   */\n  private async selectProvider(\n    request: ImageGenerationRequest,\n    options: ImageOptions\n  ): Promise<ProviderConfig> {\n    // Use explicit provider if specified\n    if (options.provider) {\n      return options.provider;\n    }\n\n    // Use default provider if no constraints\n    if (this.defaultProvider && !options.constraints) {\n      return this.defaultProvider;\n    }\n\n    // Find providers that support image generation\n    const supportedProviders = providerRegistry.getRegisteredProviders()\n      .filter(provider => {\n        const testConfig: ProviderConfig = {\n          provider,\n          model: this.getDefaultModel(provider),\n          apiKey: ''\n        };\n        const providerInstance = providerRegistry.getProvider(testConfig);\n        return providerInstance.getCapabilities().images;\n      });\n\n    if (supportedProviders.length === 0) {\n      throw new BaseSDKError(\n        'No providers support image generation',\n        'NO_SUITABLE_PROVIDER'\n      );\n    }\n\n    // Apply constraints and select best provider\n    const constraints = options.constraints;\n    if (constraints?.excludeProviders) {\n      const filtered = supportedProviders.filter(\n        p => !constraints.excludeProviders!.includes(p)\n      );\n      if (filtered.length > 0) {\n        return {\n          provider: filtered[0],\n          model: this.getDefaultModel(filtered[0]),\n          apiKey: ''\n        };\n      }\n    }\n\n    if (constraints?.preferredProviders) {\n      const preferred = supportedProviders.find(\n        p => constraints.preferredProviders!.includes(p)\n      );\n      if (preferred) {\n        return {\n          provider: preferred,\n          model: this.getDefaultModel(preferred),\n          apiKey: ''\n        };\n      }\n    }\n\n    // Default to first available provider\n    return {\n      provider: supportedProviders[0],\n      model: this.getDefaultModel(supportedProviders[0]),\n      apiKey: ''\n    };\n  }\n\n  /**\n   * Execute request with fallback providers\n   */\n  private async executeWithFallback(\n    request: ImageGenerationRequest,\n    failedProvider: ProviderConfig,\n    options: ImageOptions\n  ): Promise<ImageGenerationResponse> {\n    const fallbackProviders = this.getFallbackProviders(failedProvider);\n    \n    for (const provider of fallbackProviders) {\n      try {\n        const providerInstance = providerRegistry.getProvider(provider);\n        const capabilities = providerInstance.getCapabilities();\n        \n        if (!capabilities.images) {\n          continue; // Skip providers that don't support images\n        }\n\n        return await providerInstance.generateImages(request);\n      } catch (error) {\n        // Continue to next fallback\n        continue;\n      }\n    }\n\n    throw new BaseSDKError(\n      'All fallback providers failed for image generation',\n      'ALL_PROVIDERS_FAILED',\n      { details: { originalProvider: failedProvider.provider } }\n    );\n  }\n\n  /**\n   * Determine if error should trigger fallback\n   */\n  private shouldFallback(error: any): boolean {\n    // Fallback on rate limits, server errors, but not auth/validation errors\n    if (error.code === 'RATE_LIMIT_EXCEEDED') return true;\n    if (error.statusCode && error.statusCode >= 500) return true;\n    if (error.code === 'NETWORK_ERROR') return true;\n    return false;\n  }\n\n  /**\n   * Get fallback providers for image generation\n   */\n  private getFallbackProviders(failedProvider: ProviderConfig): ProviderConfig[] {\n    const fallbackMap: Record<string, string[]> = {\n      'openai': ['azure'], // Azure also supports DALL-E\n      'azure': ['openai']\n    };\n\n    const fallbacks = fallbackMap[failedProvider.provider] || [];\n    return fallbacks.map(provider => ({\n      provider: provider as any,\n      model: this.getDefaultModel(provider as any),\n      apiKey: ''\n    }));\n  }\n\n  /**\n   * Get default model for image generation\n   */\n  private getDefaultModel(provider: string): string {\n    const defaultModels: Record<string, string> = {\n      'openai': 'dall-e-3',\n      'azure': 'dall-e-3'\n    };\n    return defaultModels[provider] || 'dall-e-3';\n  }\n}\n\n/**\n * Convenience function to create Images instance\n */\nexport function createImages(options?: ImageOptions): Images {\n  return new Images(options);\n}\n\n/**\n * Quick helper functions\n */\nexport async function generateImage(\n  prompt: string,\n  options?: {\n    provider?: ProviderConfig;\n    size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';\n    quality?: 'standard' | 'hd';\n    style?: 'vivid' | 'natural';\n  }\n): Promise<string> {\n  const images = new Images({ provider: options?.provider });\n  return images.create(prompt, options);\n}\n\nexport async function generateImages(\n  prompt: string,\n  count: number,\n  options?: {\n    provider?: ProviderConfig;\n    size?: '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';\n    quality?: 'standard' | 'hd';\n    style?: 'vivid' | 'natural';\n  }\n): Promise<string[]> {\n  const images = new Images({ provider: options?.provider });\n  return images.createBatch(prompt, count, options);\n}"]}